/*Задача 1
Разработать векторный графический редактор, реализующий функции:
    • представление холста для рисования;
    • рисование точки;
    • рисование круга;
    • рисование прямоугольника;
    • редактирование нарисованных объектов.
При этом считать, что существует некая графическая библиотека реализующая вывод всех необходимых геометрических фигур на монитор.
Инструментарий: Объектно-ориентированный язык: C#, С++, Delphi, Python.
Средства разработки: карандаш/ручка, бумага, в виду особенностей средств разработки допускаются  упрощения и символизм в коде программы.*/

/*Условности:
- Опущена обработка ПКМ (например для отмены рисования)
- Упрощена обработка выделения примитивов (условно они все залиты), реализовать выдеение прозрачного объекта кликом по рамке возможно, но не сделано ввиду экономии времени
- Условно среда разработки позволяет создавать форму, в класс которой входят функции обработки событий нажатия ЛКМ, движения мыши по форме и отпускания ЛКМ (M_Move(int x, int y), MK_Down(int x, int y), MK_Up(int x, int y). Также форма вклчает в себя канву, на которой возможно рисование.
- Опущен момент с цветами заливки и кисти: кисть по умолчанию черная, заливка задается условным компонентом colorbox1
- В основу "программы" взята идея, что векторный рисунок - это способ хранения информации о примитивах, которые он содержит (координаты, дины  т.п.), а на экран по факту выводитс тот же растр.
*/

/*
Не сделано
-удаление примитивов
-зум
-сохранение / загрузка из файла
-изменение цвета примитивов (заливка)
-поворот примитивов представлен условно
- защита от дурака
*/


/*
Возможные ошибки:
В IDE не проверял, не отлаживал, т.к. считаю что такой подход является частью задания. Более чем уверен что ошибок много.
-ввиду небольшого опыта использования адресных операторов скорее всего ошибки с ними
-объявление классов скорее всего следует вынести в отдельный h Файл
-возможны ошибки при выборе типов данных
*/


#include"glib.h" 
/*некая графическая библиотека реализующая вывод всех необходимых геометрических фигур на монитор
функции вывода в неймспесе glib:

template <class T> void paint(T Primitive_Class) 
берет данные из объекта класса Primitive_Class (в моем случае NPrim, NCanvas)
и на их (тип, координаты, длины сторон, цвет) основе отрисовывает на канве формы примитив 

template <class T> NBorder paint_border(T Primitive_Class)
отрисовывает вокруг объекта Primitive_Class элементы редактирования (границы растягивания, точка для перемещения, точи поворота и т.д.), а также сам примитив внутри рамки

template <class T> void modify(T Primitive_Class, int ctr_i, bool ctr_e) //условно NBorder доступен в glib.h 
перерисовывает объект в зависимости от того какой элемент редактирования используется (ctr_i). Также перерисовывает элементы редактирования если ctr_e==true.
*/
#include"unit1.h" 
//заголовочный файл формы с какой-то условной информацией

#include<map>
#include<math.h>
#define PRIM1 canv1->PMap

using namespace std;

XForm1 *Form1;

//-------NBControl
struct NBControl // элемент редактирования - можно оптимизировать
{
	int c_index; //индекс 
	int c_type; //вид элемента удаления
	int c_x, c_y; //координаты
	int c_w; //радиус - условно элементы управления - квадраты
	XCursor c_cursor; //условно внешний вид курсора
}
//-------NBControl

//-------NPrim
class NPrim {//класс примитива
public:
int type; //вид примитива
	//0 - прямоугольник
	//1 - окружность
	//2 - точка
	XColor bcolor; //условно цвет заливки
	int p_x, p_y, p_w, p_h; //координаты примитива х, у, ширина и высота прямоугольника в который вписан примитив
};
//-------NPrim

//-------NBorder
class NBorder : public NPrim {//класс обводки - элементов редактирования
public:
NBControl ctr[5];
NPrim prim_tmp; //сюда, возможно, помещаем информацию об объекте редактирования
int IsCursorOnControl (int x, int y) //можно оптимизировать - вынести в базовый класс 
	{// определяем накходится ли курсор на елементе редактирования
	for(int i=5; i>=0) 
		if (i<0) return -1;
		if (((x>=c_x)&&(x<=c_x+c_w)&&(y>=c_y)&&(y<=c_y+c_w)) return i;
		else i--;
	}
NBorder ()
	{
		//отрисовка элементов управления условно вынесена в функцию paint_border
		ctr[0].c_index=0;  
		ctr[0].c_type=1; 
		ctr[0].c_cursor=crArrows;  //условно
		ctr[0].c_x=p_x-3;
		ctr[0].c_y=p_y-3;
		ctr[0].c_w=6;
		
		ctr[1].c_index=1;  
		ctr[1].c_type=1; 
		ctr[1].c_cursor=crArrows;  //условно
		ctr[1].c_x=p_x-3;
		ctr[1].c_y=p_y+p_h-3;
		ctr[1].c_w=6;
		
		ctr[2].c_index=2;  
		ctr[2].c_type=1; 
		ctr[2].c_cursor=crArrows;  //условно
		ctr[2].c_x=p_x+p_w-3;
		ctr[2].c_y=p_y-3;
		ctr[2].c_w=6;
		
		ctr[3].c_index=3;  
		ctr[3].c_type=1; 
		ctr[3].c_cursor=crArrows;  //условно
		ctr[3].c_x=p_x+p_w-3;
		ctr[3].c_y=p_y+p_h-3;
		ctr[3].c_w=6;
		
		ctr[4].c_index=3;  
		ctr[4].c_type=1; 
		ctr[4].c_cursor=crCross;  //условно
		ctr[4].c_x=round((p_x+p_w-10)/2);
		ctr[4].c_y=round((p_y+p_h-10)/2);
		ctr[4].c_w=10;
	}
};
//-------NBorder

//-------NCanvas
//класс холста
//хранит данные об объектах-примитивах нарисованных на нем 
class NCanvas : public NPrim {
public: 
	int p_count; //общее число примитивов на рисунке
	map<int, NPrim> PMap; //контейнер для хранения и обращения к примитивам вида: индекс - примитив
	//void Draw_Pic(); //отрисовка всех примитивов
	//int PickP(int x, int y); //выбор примитива для редактирования
	
NCanvas() 
	{
	this->type=0;
	this->p_count = 0;
	this->bcolor =  clwhite;
	//e.t.c
	glib::paint(this); //перерисовываем = очищаем холст		
	}
~NCanvas()
	{
	for (int i=0; i<PMap.size(); i++) delete PMap[i]; //очищаем контейнер, освобождаем память
	PMap.clear;
	}
void Draw_Pic()
	{
	glib::paint(this); //перерисовываем = очищаем холст
	for (int i=0; i<PMap.size(); i++) glib::paint(PMap[i]); //перерисовываем объекты
	}
int PickP(int x, int y) //выделение примитива на холсте для редактирования - выбор его индекса
	{
	for(int i=PMap.size(); i>=0) //можно оптимизировать - вынести в базовый класс 
		{
		if (i<0) return -1;
		else if ((x>=PMap[i].p_x)&&(x<=PMap[i].p_x+PMap[i].p_w)&&(y>=PMap[i].p_y)&&(y<=PMap[i].p_y+PMap[i].p_h)) return i;
		else i--;
		}
	}
};
//-------NCanvas

NCanvas *canv1; //выделяем память под холст
NPrim *prim1; //выделяем память под примитивы

int mode; //модификатор рисования фигур
int pcur; //выбранный пользователем для работы примитив 

NPrim *prim_tmp1; //выделяем память под эементов редактирования
int ctr_tmp1; //индекс активного элемента редактирования

//-------------------
/*WinMain / main (); //!!!!!!!!!
{
	
}*/
//-------------------
void Form1::Form_Create()
{
canv1=new NCanvas;
prim_tmp1=new NPrim;
mode=100; //устанавливаем модификатор рисования фигур в "пустой" режим
//под рисование примитивов выделяю 100 индексов (0-99) под технические нюансы остальной дапазон int 
pcur=-1; //выбранный для редактирования пользователем примитив отсутствует
ctr_tmp1=-1; //элемент редактирования не выбран
}
//-------------------
void Form1::Form_Close()
{
delete canv1, prim1, prim_tmp1;
}
//-------------------
void Form1::Button1Click() //можно оптимизировать
{
mode=0; //включаем режим рисования прямоугольника	
}
//-------------------
void Form1::Button2Click()
{
mode=1; //включаем режим рисования окружности	
}
//-------------------
void Form1::Button3Click()
{
mode=2; //включаем режим рисования точки	
}
//-------------------
void Form1::MK_Down(int x,int y) //лкм нажата в точке канвы (x;y)
{
if ((mode >= 0)	&& (mode <100)) //если активен режим рисования
{
			prim1 = new NPrim; //создаем примитив-объект
			pcur = canv1->p_count; //берем индекс этого объекта как текущий
			PRIM1[pcur].type=mode; //определяем что будем рисовать
			PRIM1[pcur]=prim1; //записываем примитив в контейнер
			PRIM1[pcur].p_x=x; //координаты начала
			PRIM1[pcur].p_y=y;
			PRIM1[pcur].bcolor=colorbox1->color; //условно	
}
else
{
switch (mode): //пространство для дальнейших изменений
	{
	case 100: //если пользователь кликнул в "пустом" режиме
		{
		if (canv1->PickP(x,y) >= 0) // если пользователь выбрал объект для редактирования
			{
			pcur=canv1->PickP(x,y);
			mode=101; //включаем режим активного элемента редактирования
			prim_tmp1=glib::paint_border(PRIM1[pcur]);//отрисовываем рамку и элементы редактирования записываем информацию в буфер 
			//в буфер помещается объект класса NBorder
			}
		}
		break;
	case 101: //если пользователь кликнул в режиме активного элемента редактирования
		{
		ctr_tmp1=prim_tmp1->IsCursorOnControl(x,y); //выясняем индекс элемента управления по которому кликнул пользователь
		if (ctr_tmp1 >= 0) // если пользователь попал по элементу управления/рамке
		{
		mode=102; //включаем непосредственно режим изменения объекта
		Form1->Cursor = prim_tmp1->ctr[ctr_tmp1].c_cursor;
		}
	break;
	default:;
	}
}
}
//-------------------
void Form1::M_Move(int x,int y) //курсор передвинулся по канве, сейчас в точке (x;y)
{
if ((mode >= 0)	&& (mode <100)) //режим рисования
{
	PRIM1[pcur].p_w=PRIM1[pcur].p_x+x; //изменяем параметры объекта
	PRIM1[pcur].p_h=PRIM1[pcur].p_y+y;
	canv1->Draw_Pic();	//перерисовываем канву
}
else
switch (mode): //пространство для дальнейших изменений
	{
	case 100: //пустой режим
	break;
	case 102: // режим изменения объекта
		{
		PRIM1[pcur].p_x=x; 
		PRIM1[pcur].p_y=y;
		PRIM1[pcur].p_w=x-PRIM1[pcur].p_x;
		PRIM1[pcur].p_h=y-PRIM1[pcur].p_y;
		glib::modify(&PRIM1[pcur],ctr_tmp1,true); /*!!!!!!!!!!!!*/
		canv1->Draw_Pic(); //перерисовываем канву
		}
		break;
	default:;
	}
}
//-------------------
void Form1::MK_Up(int x,int y) //лкм отпущена в точке канвы (x;y)
{
if ((mode >= 0)	&& (mode <100)) //режим рисования
{
	Form1->M_Move(x,y);
	canv1->p_count++;
	pcur=-1;
	mode=100;	
}
else
switch (mode): //пространство для дальнейших изменений
	{
	case 100: //пустой режим
	break;
	case 102: //если пользователь отпустил ЛКМ в режиме редактирования
		{
		PRIM1[pcur].p_x=x; 
		PRIM1[pcur].p_y=y;
		PRIM1[pcur].p_w=PRIM1[pcur].p_x+x;
		PRIM1[pcur].p_h=PRIM1[pcur].p_y+y;
		glib::modify(&PRIM1[pcur],ctr_tmp1,false);
		canv1->Draw_Pic()
		ctr_tmp1=-1;
		p_cur=-1;
		mode=100;
		}
		break;
	default:;	
	}
}
